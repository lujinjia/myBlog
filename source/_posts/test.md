---
title: JS作用域
date: 2018-07-23 15:00:12
tags:
---


1. 作用域分类2222
变量的作用域取决于变量定义时所在的位置，如果是定义在全局上的，就是全局作用域、定义在函数中的，则为函数作用域。作用域是相互嵌套的，小的作用域会覆盖大的作用域，定义在函数内部的作用域可以在执行时覆盖全局作用域的变量
2. JS缺失的作用域
变量提升，C系语言中，有块级作用域的概念。块级作用域是在包裹在大括号中的作用域，ES5及之前的JS中没有块级作用域的概念，容易造成变量相互影响，不利于开发和调试。可以通过使用将代码块包裹在函数里面，也就是IIFE立执行表达式来模拟块级作用域。在一个函数作用域中定义的所有变量，会自动将定义语句放在函数顶部来首先执行，这就是变量提升。块级作用域的缺失导致了内层变量可能会覆盖外层变量，用来计数的循环变量会泄露为全局变量，块级作用域的出现使IIFE不再必要了。在块级作用域可以声明函数，在块级作用域外不可引用，由于各浏览器厂商对于此实现不同，不建议在实际项目中使用，可以通过使用函数表达式
3. 作用域链
JS是基于词法作用域的语言，词法作用域是指当定义一个函数时，当前的作用域会保存下来，并且作为函数状态的一部分。也叫作静态作用域，它的作用域是指在词法分析的阶段就已经确定了。而动态作用域是指在运行时根据程序的流程信息来动态确定作用域。词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。静态作用域规则是查找一个变量声明时依赖的是源程序中块之间的静态关系；而动态作用域依赖的是程序执行时的函数调用顺序。

4. 闭包
    由于作用域链的不可向下性，就需要闭包来使外部函数持有内部函数的一个嵌套函数的引用。闭包是为了实现词法作用域而用到的一种数据结构。JavaScript采用词法作用域，也就是说函数的执行依赖于变量的作用域，这个作用域是在函数定义时决定的，而不是函数调用时决定的。为了实现词法作用域，JavaScript函数对象的内部状态不仅包含函数的代码逻辑，还必须引用当前的作用域链。函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为"闭包"。当定义一个函数时，它实际上保存了一个作用域链。当调用这个函数时，它创建一个新的对象来存储它的局部变量，并将这个对象添加到保存的作用域链上。

5. this
    this一般用来代表函数的调用对象，它和上下文对象并不是同一个，上下文对象对我们来说是不可见的，除了全局作用域。this一般是指向一个对象，而具体指向那个对象，则是根据运行时基于函数的执行环境动态绑定的，而非环境声明时的环境。this的指向是根据函数的调用方式来决定的，一般函数的调用方式有四种
- 作为对象的方法来调用 this指向该对象
- 作为普通函数调用 this指向全局对象
- 构造器调用 一般是指向new完返回的对象，但是如果显示返回一个object的对象，运算结果会返回这个对象
- Function.prototype.call或者Function.prototype.apply调用 可以动态改变this的指向

6. call和apply
 都可以动态改变this的取向，它们的区别是传入的参数形式不同。apply第一个参数指向函数体内this对象的指向，第二个参数是带下标的集合。而call的第二个参数则是传入的参数数量不固定，每个参数被依次传入函数。call方法是基于apply封装的语法糖，如果需要明确表达形参和实参之间的关系，则可以使用call来传递参数，一般情况下用apply更多。使用此类方法可以动态借用其他对象的方法。
- 改变this的指向
- Function.prototype.bind
- 借用其他对象的方法

4. 解决方案
- IIFE，立执行表达式
- let关键字
- const关键字
    声明一个只读的变量，一旦声明，常量的值便不可修改。只在块级作用域生效，存在暂时性死区情况，不可重复声明。const保证变量指向的那个内存地址不可改动，但是如果指向的是一个符合类型的数据，比如对象，仍然可以为其增减属性或者改变值，可以使用Object.freeze来防止属性修改
    
5. 项目应用

6. 浏览器兼容